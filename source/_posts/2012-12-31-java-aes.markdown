---
layout: post
title: "続・Androidの画像の暗号化"
date: 2012-12-31 23:30
comments: true
categories: Java Encrypto AES
---

前にベンチ取ったときは遅くて使えないって思ったけど、「いやそんなに遅くないでしょう」と言われたので、一からやり直した。

## AES暗号とは

AES暗号はアメリカ合衆国の新暗号規格 (Advanced Encryption Standard) として規格化された共通鍵暗号方式である。1977年に発行された暗号規格DESの安全性が技術進歩により低下したため、新たな暗号方式の公募を行い、2001年3月に FIPS PUB 197 として公表され、米軍主導のネットワーク秘匿化オープンソースプロジェクトであるTorなどに採用された。 〜wikipediaより〜  

とりあえずAESは、「ブロック暗号」で「ブロック長が128ビット」で「鍵長が128・192・256ビットの3つが利用できる」ということみたいです。

## AESによる暗号化・復号化

[AESによる暗号化・復号化](http://www.ne.jp/asahi/hishidama/home/tech/java/aes.html)  
今回はAndroidで画像をストレージに保存する際の暗号化について考えます。

#### コード

ENCRYPT_ALGORYTHM = "AES/CBC/PKCS5Padding"
とありますが、これはAESを[CBCモード](http://www.triplefalcon.com/Lexicon/Encryption-Block-Mode-1.htm)で[PKCS#5](http://pentan.info/doc/block_cipher.html#anc_padding)というパディング方式で暗号化するということです。

![CBC Encryption](http://upload.wikimedia.org/wikipedia/commons/d/d3/Cbc_encryption.png)

- encrypt: 保存先のファイルと画像を引数にして、画像を暗号化して保存する
- decrypt: ファイル名を引数にして、復号した画像を返す

{% codeblock lang:java %}
public class ImageEncryptor {

    private static final String TAG = ImageEncryptor.class.getSimpleName();
    private static final String ENCRYPT_ALGORYTHM = "AES/CBC/PKCS5Padding";
    private static final int DEFAULT_KEY_LENGTH = 16;
    private static String mPassword = null;

    // アプリ固有の情報ということでアプリをインストールした時間をもとに、
    // getByte()したときにデフォルトの鍵長の128ビットになるStringを返す
    public static String getPassword(Context context) {
        if (mPassword != null) return mPassword;

        PackageInfo packageInfo = null;
        try {
            packageInfo = context.getPackageManager()
                    .getPackageInfo(context.getApplicationInfo().packageName, PackageManager.GET_META_DATA);
        } catch (NameNotFoundException e) {
            Log.e(TAG, e.toString());
            return null;
        }

        long installTime = packageInfo.firstInstallTime;
        mPassword = formatValidPassword(String.valueOf(installTime));
        return mPassword;
    }

    private static String formatValidPassword(String password) {
        while (password.length() < DEFAULT_KEY_LENGTH) {
            password = "0" + password;
        }
        return password;
    }

    public static void encrypt(String filePath, Bitmap bitmap, String password) 
            throws FileNotFoundException, IOException {
        encrypt(new File(filePath), bitmap, password);
    }
    
    public static void encrypt(File file, Bitmap bitmap, String password) 
            throws FileNotFoundException, IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        bitmap.compress(CompressFormat.JPEG, 100, baos);
        byte[] bin = baos.toByteArray();

        encrypt(file, bin, password);
    }

    public static void encrypt(String filePath, byte[] content, String password) 
            throws FileNotFoundException, IOException {
        encrypt(new File(filePath), content, password);
    }
    
    public static void encrypt(File file, byte[] content, String password) 
            throws FileNotFoundException, IOException {

        FileOutputStream fos = null;
        CipherOutputStream cos = null;
        try {
            Cipher cipher = Cipher.getInstance(ENCRYPT_ALGORYTHM);
            cipher.init(Cipher.ENCRYPT_MODE, getKey(password));
            fos = new FileOutputStream(file);
            cos = new CipherOutputStream(fos, cipher);
            fos.write(cipher.getIV());
            cos.write(content);
            cos.flush();
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, e.toString());
        } catch (NoSuchPaddingException e) {
            Log.e(TAG, e.toString());
        } catch (InvalidKeyException e) {
            Log.e(TAG, e.toString());
        } finally {
            CloseableUtils.close(cos);
        }
    }

    public static Bitmap decrypt(String filePath, String password) {
        CipherInputStream cis = null;
        try {
            FileInputStream fis = new FileInputStream(filePath);
            byte[] iv = new byte[DEFAULT_KEY_LENGTH];
            fis.read(iv);
            Cipher cipher = Cipher.getInstance(ENCRYPT_ALGORYTHM);
            IvParameterSpec ivspec = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, getKey(password), ivspec);
            cis = new CipherInputStream(fis, cipher);
        } catch (FileNotFoundException e) {
            Log.e(TAG, e.toString());
        } catch (IOException e) {
            Log.e(TAG, e.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, e.toString());
        } catch (NoSuchPaddingException e) {
            Log.e(TAG, e.toString());
        } catch (InvalidKeyException e) {
            Log.e(TAG, e.toString());
        } catch (InvalidAlgorithmParameterException e) {
            Log.e(TAG, e.toString());
        }
        if (cis == null) return null;

        Bitmap bitmap = null;
        try {
            bitmap = BitmapFactory.decodeStream(cis, null, null);
        } finally {
            CloseableUtils.close(cis);
        }
        return bitmap;
    }

    private static Key getKey(String password) {
        return new SecretKeySpec(password.getBytes(), "AES");
    }
}
{% endcodeblock %}_

## ベンチマーク

![](http://dl.dropbox.com/u/54255753/blog/201212/madoka.jpg)
うちに届いた年賀状の画像の暗号化にどれくらい時間がかかるのか計測してみました。

- サイズ: 864px * 480px
- 端末スペック: Xperia arc
  - OS  Google Android 2.3
  - CPU: Snapdragon 1GHz(MSM8255)
  - RAM: 512MB

{% codeblock 検証コード lang:java %}
long start = System.currentTimeMillis();
ImageEncryptor.encrypt(filePath, bitmap, password);
ImageEncryptor.decrypt(filePath, password);
long stop = System.currentTimeMillis();
Log.d("DEBUG", "実行にかかった時間は " + (stop - start) + " ミリ秒です。");
{% endcodeblock %}


{% codeblock 結果 lang:java %}
01-02 14:41:02.026: D/DEBUG(26043): 実行にかかった時間は 1177 ミリ秒です。
01-02 14:40:17.496: D/DEBUG(26043): 実行にかかった時間は 1149 ミリ秒です。
01-02 14:40:38.406: D/DEBUG(26043): 実行にかかった時間は 1233 ミリ秒です。
{% endcodeblock %}

traceviewでも確認

![](http://dl.dropbox.com/u/54255753/blog/201212/trace.png)

AESFastEngine.encryptBlockが7割、AESFastEngine.decryptBlockが3割くらいですね。

## まとめ

暗号化にどれくらい時間かかるのかなと思ったけど、あまりサイズが大きくなければわりと実用的っぽい！

<link href="http://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet" type="text/css">
