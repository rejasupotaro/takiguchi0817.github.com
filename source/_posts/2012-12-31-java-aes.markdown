---
layout: post
title: "続・Androidの画像の暗号化"
date: 2012-12-31 23:30
comments: true
categories: Java Encrypto AES
---

前にベンチ取ったときは遅くて使えないって思ったけど、「いやそんなに遅くないでしょう」と言われたので、一からやり直しました。

## AES暗号とは

AES暗号はアメリカ合衆国の新暗号規格 (Advanced Encryption Standard) として規格化された共通鍵暗号方式である。1977年に発行された暗号規格DESの安全性が技術進歩により低下したため、新たな暗号方式の公募を行い、2001年3月に FIPS PUB 197 として公表され、米軍主導のネットワーク秘匿化オープンソースプロジェクトであるTorなどに採用された。 〜wikipediaより〜  

とりあえずAESは、「ブロック暗号」で「ブロック長が128ビット」で「鍵長が128・192・256ビットの3つが利用できる」ということみたいです。

## AESによる暗号化・復号化

[AESによる暗号化・復号化](http://www.ne.jp/asahi/hishidama/home/tech/java/aes.html)  
今回はAndroidで画像をストレージに保存する際の暗号化について考えます。

#### コード

ENCRYPT_ALGORYTHM_MODE が "AES/CTR/PKCS5Padding" となっていますが、
これはAESをCTRモードで[PKCS#5](http://pentan.info/doc/block_cipher.html#anc_padding)というパディング方式で暗号化するということです。

![CBC Encryption](http://upload.wikimedia.org/wikipedia/commons/d/d3/Cbc_encryption.png)

- encrypt: 保存先のファイルと画像を引数にして、画像を暗号化して保存する
- decrypt: ファイル名を引数にして、復号した画像を返す

※追記：このコードはそのまま使えません！パスワードの生成については一番最後をお読みください。

{% codeblock lang:java %}
package com.rejasupotaro.sampleapp.encrypt;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.util.Log;

import com.rejasupotaro.sampleapp.utils.CloseableUtils;

public class ImageEncryptor {

    private static final String TAG = ImageEncryptor.class.getSimpleName();
    private static final String ENCRYPT_ALGORYTHM = "AES";
    private static final String ENCRYPT_ALGORYTHM_MODE = ENCRYPT_ALGORYTHM + "/CTR/PKCS5Padding";
    private static final int DEFAULT_KEY_LENGTH = 16;
    private static String mPassword = null;

    // アプリ固有の情報ということでアプリをインストールした時間をもとに、
    // getByte()したときにデフォルトの鍵長の128ビットになるStringを返す
    // !!!!このやり方には問題があります。追記を参照!!!!
    public static String getPassword(Context context) {
        if (mPassword != null) return mPassword;

        PackageInfo packageInfo = null;
        try {
            packageInfo = context.getPackageManager()
                    .getPackageInfo(context.getApplicationInfo().packageName, PackageManager.GET_META_DATA);
        } catch (NameNotFoundException e) {
            Log.e(TAG, e.toString());
            return null;
        }

        long installTime = packageInfo.firstInstallTime;
        mPassword = formatValidPassword(String.valueOf(installTime));
        return mPassword;
    }

    private static String formatValidPassword(String password) {
        while (password.length() < DEFAULT_KEY_LENGTH) {
            password = "0" + password;
        }
        return password;
    }

    public static void encrypt(String filePath, Bitmap bitmap, String password) 
            throws FileNotFoundException, IOException {
        encrypt(new File(filePath), bitmap, password);
    }
    
    public static void encrypt(File file, Bitmap bitmap, String password, byte[] iv) 
            throws FileNotFoundException, IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        bitmap.compress(CompressFormat.JPEG, 100, baos);
        byte[] bin = baos.toByteArray();

        encrypt(file, bin, password, iv);
    }

    public static void encrypt(String filePath, byte[] content, String password, byte[] iv) 
            throws FileNotFoundException, IOException {
        encrypt(new File(filePath), content, password);
    }
    
    public static void encrypt(File file, byte[] content, String password, byte[] iv) 
            throws FileNotFoundException, IOException {

        FileOutputStream fos = null;
        try {
            Cipher cipher = Cipher.getInstance(ENCRYPT_ALGORYTHM);
            cipher.init(Cipher.ENCRYPT_MODE, getKey(password), new IvParameterSpec(iv));
            fos = new FileOutputStream(file);
            fos.write(cipher.doFinal(content));
        } catch (NoSuchAlgorithmException e) {
            Log.v(TAG, e.toString());
        } catch (NoSuchPaddingException e) {
            Log.v(TAG, e.toString());
        } catch (InvalidKeyException e) {
            Log.v(TAG, e.toString());
        } catch (InvalidAlgorithmParameterException e) {
            Log.v(TAG, e.toString());
        } catch (IllegalBlockSizeException e) {
            Log.v(TAG, e.toString());
        } catch (BadPaddingException e) {
            Log.v(TAG, e.toString());
        } finally {
            CloseableUtils.close(fos);
        }
    }

    public static Bitmap decrypt(String filePath, String password, byte[] iv) {
        FileInputStream fis = null;
        CipherInputStream cis = null;
        Bitmap bitmap = null;
        try {
            fis = new FileInputStream(filePath);
            Cipher cipher = Cipher.getInstance(ENCRYPT_ALGORYTHM_MODE);
            IvParameterSpec ivspec = new IvParameterSpec(initialVector);
            cipher.init(Cipher.DECRYPT_MODE, getKey(password), ivspec);
            cis = new CipherInputStream(fis, cipher);
 
            bitmap = BitmapFactory.decodeStream(cis, null, null);
        } catch (FileNotFoundException e) {
            Log.v(TAG, e.toString());
        } catch (IOException e) {
            Log.v(TAG, e.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.v(TAG, e.toString());
        } catch (NoSuchPaddingException e) {
            Log.v(TAG, e.toString());
        } catch (InvalidKeyException e) {
            Log.v(TAG, e.toString());
        } catch (InvalidAlgorithmParameterException e) {
            Log.v(TAG, e.toString());
        } finally {
            CloseableUtils.close(fis);
            CloseableUtils.close(cis);
        }
 
        return bitmap;
    }

    private static Key getKey(String password) {
        return new SecretKeySpec(password.getBytes(), ENCRYPT_ALGORYTHM);
    }
}
{% endcodeblock %}_

動作モードについて補足すると、  

- ECB(Electronic CodeBook)電子符号表モード
  - 単純にブロックごとに暗号化する。安全でなく使うべきでない。
- CTR(Counter)カウンターモード
  - 各ブロックを初期値から1ずつ増加するカウンタの暗号化との排他的論理和で暗号化する。各ブロックを並列に処理できる。
- CBC(Cipher Block Chaining)暗号ブロック連鎖モード
  - ブロックを前ブロックの暗号化結果と排他的論理和を取ってから暗号化する。最初のブロックは初期ベクタという乱数と排他的論理和を取る。
- CFB(Cipher Feed Back)暗号フィードバックモード
  - 前ブロックを暗号化してブロックとの排他的論理和をとって暗号文とする。最初のブロックは初期ベクタの暗号化との排他的論理和で暗号化する。
- OFB(Output Feed Back)出力フィードバックモード
  - 初期ベクタに繰り返し暗号化処理して乱数ストリームを作り、これと平文との排他的論理和を暗号文とする。

ということらしいです。詳しくは[こちら](http://akademeia.info/index.php?%A5%D6%A5%ED%A5%C3%A5%AF%B0%C5%B9%E6%A4%CE%CD%F8%CD%D1%A5%E2%A1%BC%A5%C9#pdc05fdd)

## ベンチマーク

![](http://dl.dropbox.com/u/54255753/blog/201212/madoka.jpg)
うちに届いた年賀状の画像の暗号化にどれくらい時間がかかるのか計測してみました。

- サイズ: 864px * 480px
- 端末スペック: Xperia arc
  - OS  Google Android 2.3
  - CPU: Snapdragon 1GHz(MSM8255)
  - RAM: 512MB

{% codeblock 検証コード lang:java %}
long start = System.currentTimeMillis();
ImageEncryptor.encrypt(filePath, bitmap, password);
ImageEncryptor.decrypt(filePath, password);
long stop = System.currentTimeMillis();
Log.d("DEBUG", "実行にかかった時間は " + (stop - start) + " ミリ秒です。");
{% endcodeblock %}


{% codeblock 結果 lang:java %}
01-02 14:41:02.026: D/DEBUG(26043): 実行にかかった時間は 1177 ミリ秒です。
01-02 14:40:17.496: D/DEBUG(26043): 実行にかかった時間は 1149 ミリ秒です。
01-02 14:40:38.406: D/DEBUG(26043): 実行にかかった時間は 1233 ミリ秒です。
{% endcodeblock %}

traceviewでも確認

![](http://dl.dropbox.com/u/54255753/blog/201212/trace.png)

AESFastEngine.encryptBlockが7割、AESFastEngine.decryptBlockが3割くらいですね。

## まとめ

暗号化にどれくらい時間かかるのかなと思ったけど、あまりサイズが大きくなければわりと実用的っぽい！

## 追記

パスワードの生成でアプリのインストール時間を見ていましたが、firstInstallTimeがAPI level 9からだったので、Androidバージョン2.1と2.2で使えませんでした。
なので別の方法を考えようと思っていたら、[書籍「Android Security」の暗号鍵生成方法には課題がある](http://d.hatena.ne.jp/ockeghem/20120213/p1) という記事を見つけました。
というわけでランダムなbyte列を16個生成して128bitにすることにした。

{% codeblock lang:java %}
byte[] bytes = new byte[16];
SecureRandom rand = new SecureRandom();
rand.nextBytes(bytes);
{% endcodeblock %}_

このようにパスワードを生成します。
RandomじゃなくてSecureRandomを使った方が良いです。
またパスワードはStringで持つのではなくbyte[]で持っていた方が良いです。
SQLiteに保存するならBLOBで、SharedPreferenceならbase64にエンコードして書き込むようにします。

<link href="http://fonts.googleapis.com/css?family=Cantarell" rel="stylesheet" type="text/css">
