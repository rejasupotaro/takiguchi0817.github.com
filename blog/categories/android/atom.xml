<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Just posted a blog]]></title>
  <link href="http://takiguchi0817.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://takiguchi0817.github.com/"/>
  <updated>2013-10-13T23:33:45+09:00</updated>
  <id>http://takiguchi0817.github.com/</id>
  <author>
    <name><![CDATA[rejasupotaro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Androidのデータ保存パターン]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/10/13/saving-data/"/>
    <updated>2013-10-13T22:36:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/10/13/saving-data</id>
    <content type="html"><![CDATA[<p>新しくアプリを作るときにAndroid内でのデータの持ち方や、アクセスの仕方、モデルの扱い方には色々あってどうしようってなると思うので、僕の少ない経験から考えたことをまとめます。</p>

<h1>ファイルに保存</h1>

<p>DBは注意して使わないとデータがアップデートしたら全部消えましたとか、あるカラムだけデータが入ってませんでしたとかあるので、データの簡易保存、たとえばレスポンスのjsonをそのままキャッシュするとか、検索する必要がなかったりあまり更新しないモデルをシリアライズして保存するときにはファイル保存が向いていると思います。</p>

<p>なお、JavaのSerializableは柔軟性が低く、バージョンアップでデータを壊してアプリが落ちるということが分かっていてもハンドリングできなくて防ぐのが難しかったりするので、シリアライズするときはgsonとかmessagepackを使うことをオススメします。</p>

<p>ただこのやり方でもキャッシュを管理するためのFileManager的なクラスは必要になってくると思うので、あまり複雑なことをやるのであればDBを使った方が楽になってくると思います。
独自のFileManagerクラスを作り込んでしまうと新しく入ってきた人がつらいですしね。</p>

<h1>DBに保存(素SQL)</h1>

<p>手でSQLを書くのはつらいです。人間はミスをするのでORMを使った方がいいと思います。</p>

<h1>ORM(ActiveAndroid)を利用してDBに保存</h1>

<p><a href="http://d.hatena.ne.jp/nattou_curry_2/20090102/1230903865">ActiveRecordパターン</a>のORMです。</p>

<h2>モデル定義</h2>

<p>```java
@Table(name = "Items")
public class Item extends Model {
  @Column(name = "Name", notNull = true, unique = true) // カラム名と制約を付けることができる　
  public String name; // ModelのFieldはpublicにしなければならない</p>

<p>  @Column(name = "Category") // リレーションが持てる
  public Category category;
}</p>

<p>@Table(name = "Categories")
public class Category extends Model {
  @Column(name = "Name")
  public String name;</p>

<p>  public List<Item> items() {</p>

<pre><code>return getMany(Item.class, "Category");
</code></pre>

<p>  }
}
```</p>

<h3>補足</h3>

<p>MedelのFieldに<a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/Model.java#LC40">Idが定義</a>されていて、テーブルを作るときに<a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/util/SQLiteUtils.java#LC161">Primary Keyになります。</a>
とはいえ内部的なIdだけでなく、サーバーからのレスポンスにIdも入っていると思うので、</p>

<p>```java
@Table(name = "Items")
public class Item extends Model {</p>

<pre><code>@Column(name = "ItemId")
public String id;

@Column(name = "Name", notNull = true, unique = true) // カラム名と制約を付けることができる　
public String name; // ModelのFieldはpublicにしなければならない

@Column(name = "Category") // リレーションが持てる
public Category category;
</code></pre>

<p>}
```</p>

<p>このように親クラスのIdとカラム名が被らないように定義して <code>item.id</code> でアクセスするのはどうだろうかと考えています。ここでうっかり <code>item.getId()</code> とすると思っていたのと違う値が返ってくるとかあるので注意が必要です。</p>

<p>リリース後にモデルのフィールドを変更した際にはmigrationをする必要があります。詳しくはmigrationのところで書きますが、モデルの変更は注意が必要です。</p>

<h2>Query</h2>

<h3>Save</h3>

<p><code>java
item = new Item();
item.category = restaurants;
item.name = "Red Robin";
item.save();
</code></p>

<h3>Delete</h3>

<p><code>java
Item item = Item.load(Item.class, 1);
item.delete();
// or
new Delete().from(Item.class).where("Id = ?", 1).execute();
</code></p>

<h3>Bulk insert</h3>

<p>```java
ActiveAndroid.beginTransaction();
try {</p>

<pre><code>    for (int i = 0; i &lt; 100; i++) {
        Item item = new Item();
        item.name = "Example " + i;
        item.save();
    }
    ActiveAndroid.setTransactionSuccessful();
</code></pre>

<p>}
finally {</p>

<pre><code>    ActiveAndroid.endTransaction();
</code></pre>

<p>}
```</p>

<p>トランザクションでラップすると40msで、使わないと4secかかるとのことです。</p>

<h3>補足</h3>

<p><a href="https://github.com/pardom/ActiveAndroid/blob/91bca4983a7da882b6585f124288f1aac7b299ef/src/com/activeandroid/query/From.java#LC54">join、leftJoin、outerJoin、innerJoin、crossJoinもできます。</a></p>

<h2>Migration</h2>

<p><code>/assets/migraions/2.sql</code> のようにsqlを置いておくとonUpgradeで実行されます。
カラムを追加するだけなら以下の書けます。</p>

<p><code>sql
ALTER TABLE Items ADD COLUMN price INTEGER;
</code></p>

<p>migrationはバージョンアップ後にユーザーの手元で<a href="https://github.com/pardom/ActiveAndroid/blob/791652b3fbf130448a5b152d12764a451e421b47/src/com/activeandroid/DatabaseHelper.java#LC137">順番に実行される</a>ので、アプリをインストールしてからしばらく期間をおいてからそのユーザーがアプリのバージョンアップをしたとすると、空いた期間分のマイグレーションが走って初回起動にやや時間がかかるかと思います。(そこまで大きな影響があるとは思いませんが)
起動時間より、migrationファイルを作り忘れたとかそっちの方がこわいので、モデルを変更するとき・レビューするときには気をつけて見たほうがよさそうです。</p>

<h2>その他ORMとの比較</h2>

<p>```java
// GreenDAO
List<Todo> ended = daoSession.getTodoDao().queryBuilder()</p>

<pre><code>    .where(new StringCondition(
        TodoDao.Properties.Status.columnName + "=?",
        Integer.toString(TodoDaoHelper.STATUS_END))).list();
</code></pre>

<p>// ActiveAndroid
new Select().from(Todo.class).where("Status=?", STATUS_END).execute();
```</p>

<p>greenDAOも見てみたのですが、daoSessionを引き回さないといけないのと、全体的に冗長だなという印象です。その分DAOの方がバグが入りにくそうなので、用途によって選択すればいいと思います。</p>

<p>See also:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/13680954/green-dao-vs-orm-lite-vs-active-android">Green DAO vs ORM lite vs Active Android</a></li>
<li><a href="http://software-workshop.eu/content/comparing-android-orm-libraries-greendao-vs-ormlite">Comparing android ORM libraries - GreenDAO vs Ormlite</a></li>
</ul>


<h1>まとめ</h1>

<p>キャッシュはファイルに保存して、モデルは要件に応じてORMを使ってDBに保存するのがいいと思います。
もしActiveAndroidを使うならAPIレスポンスをgsonとかで直接モデルに変換するとカオスになるのでentityを作るのがいいです、みたいにデータ保存はアプリの全体設計に関わってくるので、もし新しくアプリを作る場合はなるべく早い段階から検討をするといいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Narive UI]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/10/07/native-ui/"/>
    <updated>2013-10-07T23:55:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/10/07/native-ui</id>
    <content type="html"><![CDATA[<p>人は何を見てアプリっぽいと感じるのだろうか。</p>

<div>
<img src="http://gifzo.net/jTEl4YmZqD.gif" style="float:left">
<img src="http://gifzo.net/BHFQmyIfFHF.gif" style="float:left">
</div>




<div style="clear:both">
<img src="http://gifzo.net/BWvNCrQFYfF.gif" style="float:left">
<img src="http://gifzo.net/BGth4C1Ok64.gif" style="float:left">
</div>




<div style="clear:both">
<img src="http://gifzo.net/lSwyh4fg6P.gif" style="float:left">
<img src="http://gifzo.net/68NrYQW2tB.gif" style="float:left">
</div>




<div style="clear:both">
<img src="http://gifzo.net/OKyqq1D9yD.gif" style="float:left">
<img src="http://gifzo.net/mtHN4UIAMZ.gif" style="float:left">
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feed UI Patterns]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/10/06/feed-ui-patterns/"/>
    <updated>2013-10-06T17:50:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/10/06/feed-ui-patterns</id>
    <content type="html"><![CDATA[<p>タイムラインとかフィードを見る系でいい感じのアプリない？と聞かれたのでアプリのUIを眺めていました。</p>

<h3>Feedly</h3>

<p><img src="https://dl.dropboxusercontent.com/u/54255753/blog/201310/feedly.png" width="300px"></p>

<h3>foursquare</h3>

<p><img src="http://img1.mobile-patterns.com/img/full/1363118152348-2013-03-03%2020.23.25.png" width="300px"></p>

<h3>YouTube</h3>

<p><img src="http://img3.mobile-patterns.com/img/full/1363118191519-2013-03-03%2022.46.46.png" width="300px"></p>

<h3>SocialCam</h3>

<p><img src="http://25.media.tumblr.com/tumblr_lyr31slYLr1r750h1o1_500.png" width="300px"></p>

<h3>Path</h3>

<p><img src="http://31.media.tumblr.com/tumblr_lvifhic1MU1r750h1o1_500.jpg" width="300px"></p>

<h3>Pinterest</h3>

<p><img src="https://dl.dropboxusercontent.com/u/54255753/blog/201310/pinterest.png" width="300px"></p>

<h3>Gunosy</h3>

<p><img src="https://dl.dropboxusercontent.com/u/54255753/blog/201310/gunosy.png" width="300px"></p>

<p>見比べてみて、誰が投稿したか、誰が投稿に対して反応したか、何時に投稿されたか、何を最初に知らせたいのか、写真を良く見せたい、などそのサービスにとって何が重要なのかによって "いい感じ" の意味が変わってくるなあと思いました。</p>

<p>ちなみに僕はデザインの引き出しが少ないので、まとめサイト的なものを見て探しています。</p>

<ul>
<li><a href="http://www.mobile-patterns.com/">Mobile UI Patterns</a></li>
<li><a href="http://www.mobiledesignpatterngallery.com/mobile-patterns.php">Mobile Design Pattern Gallery</a></li>
<li><a href="">Android Interaction Design Patterns</a></li>
<li><a href="http://www.androidviews.net/">AndroidViews</a></li>
<li><a href="http://www.androiduipatterns.com/">Android // UI Patterns</a></li>
<li><a href="http://www.lovelyui.com/">lovely ui</a></li>
<li><a href="http://androidpttrns.com/">android pttrns</a></li>
<li><a href="http://androidniceties.tumblr.com/">Android Niceties</a></li>
<li><a href="http://www.uxarchive.com/">UX Archive</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[S3でmavenリポジトリをホストしてGradleでアップロードする]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/09/30/upload-to-s3/"/>
    <updated>2013-09-30T22:52:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/09/30/upload-to-s3</id>
    <content type="html"><![CDATA[<p>bucket, key, secretは外部ファイルに定義しておきます。</p>

<p>```groovy
configurations {</p>

<pre><code>deployerJars
</code></pre>

<p>}
repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>}
dependencies {</p>

<pre><code>deployerJars 'org.springframework.build.aws:org.springframework.build.aws.maven:3.0.0.RELEASE'
</code></pre>

<p>}</p>

<p>uploadArchives {</p>

<pre><code>repositories {
    mavenDeployer {
        configuration = configurations.deployerJars

        repository(url: "s3://${project.s3Bucket}/release") {
            authentication(userName: project.s3Key, passphrase: project.s3Secret)
        }

        pom.groupId = 'com.rejasupotaro'
        pom.artifactId = 'mylibrary'
        pom.version = '1.0.0'
    }
}
</code></pre>

<p>}
```</p>

<p>これで gradle uploadArchives すればアップロードすることができます。</p>

<p>ライブラリを使う側は以下のようにします。</p>

<p>```groovy
repositories {</p>

<pre><code>maven {
    url "https://${project.s3Bucket}.s3.amazonaws.com/release"
    credentials {
        username project.s3Key
        password project.s3Secret
    }
}
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile 'com.rejasupotaro:mylibrary:1.0.0'
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android開発を始めたばかりの僕が読みたかった本]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/09/28/android-books/"/>
    <updated>2013-09-28T00:42:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/09/28/android-books</id>
    <content type="html"><![CDATA[<p><img src="https://dl.dropboxusercontent.com/u/54255753/blog/201309/reading.png" alt="" /></p>

<p>最近、スマートフォンアプリ開発をやる人増えてきてオススメの本ある？って聞かれること多くなってきたのですが、その人のバックグラウンドによるところも大きいと思うので、自分がAndroidアプリ開発を始めたときに読んでて役に立った、あるいは読んでおきたかったという目線で、良かった本をいくつか挙げようと思います。</p>

<h2>Effective Java</h2>

<p>Java界隈では多くの人が読んでいると思いますが、AndroidからJavaに入った人だと読んだことがない人もいると思います。
Javaを書く上でのエッセンスが詰め込まれているので、まだ読んでいない方は読むことをおすすめします。</p>

<h2>JUnit実践入門</h2>

<p>Androidだとテストが書かれないことが多いです。しかし、書いた方がデバッグの時間が短くなる上に保守もしやすくなりますし、テストを書きやすい構造を意識するようになって、上達が早くなりますし、設計も綺麗になります。(と思います)
僕も最初はテストを書かなかったのですが、もっと早くからテストを書いていればなと思っています。</p>

<h2>現場で使える[逆引き+実践]Androidプログラミングテクニック</h2>

<p>逆引き系の本なのですが、それだけでなく <strong>SQLiteの処理を高速化したい</strong> であったり、<strong>OutMemoryErrorをなんとか回避したいとか</strong> や、<strong>複数のアクティビティで共通の処理を、Template Methodパターンで実装したい/移譲で実装したい/Strategyパターンで実装したい</strong> など、デザインパターンや実践的なノウハウが詰まっている良い本でした。</p>

<h2>SMASHING Android UI</h2>

<p><a href="http://www.androiduipatterns.com/">Android // UI PATTERNS</a> というブログで有名なJuhani Lehtimakiさんの本です。最近翻訳されて日本で発売されました。
この本も、ただUIのコンポーネントの説明に終わるだけでなく、デザインとどう向き合うかや、ユーザーテストのやり方や、Androidプラットフォームの課題など、スマートフォンエンジニアにとって重要なデザインのことが学べる数少ない良書だと思います。</p>

<hr />

<p>ここから先はAndroidのさらに高度なプログラムを書きたい人向けです。</p>

<h2>Java言語で学ぶデザインパターン入門【マルチスレッド編】</h2>

<p>通信などの非同期処理、並列処理を書くときに、パフォーマンスの悪いプログラムを書いてしまったり、最悪デッドロックを起こしてしまったりしてしまわないために、特にこれからライブラリを書く人はこの本を読んだ方がいいです。
またライブラリを書かない人でもこの本を読んでおくと「ああ、あのパターンで実装されているのか！」みたいに、理解の助けになったりします。</p>

<h2>サクサク動く！Androidアプリ高速化プログラミング</h2>

<p>アプリの規模が大きくなってきてパフォーマンスに問題を感じるようになったり、局所的にプログラムを速くしたいというときにはこの本がおすすめです。デバッグ手法やレイアウトの最適化の話から、アセンブラやメモリアクセスやGCの話もあるので、読み物としても面白かったです。</p>

<hr />

<p>その他、本以外に参考にしているもの</p>

<h2><a href="https://twitter.com/androidniceties">@androidniceties</a></h2>

<p>Android Nicetiesのtumblrの更新をツイートしてくれます。
デザインを専門に学んでいなかった僕は、とにかく多くのパターンに触れなければと思っています。デザインは0から生まれるものではなく、過去の事例であったり、自然界に存在する美しいものの模倣から生まれるみたいな話がありますし、なにより実績のあるアプリのデザインは僕が考えだしたUIより質が高いです。</p>

<h2><a href="http://www.androidviews.net/">ANDROIDVIEWS</a></h2>

<p>あのアプリの実装オシャレだなとか思ったら、ここに載っていたりします。
自分で実装するときの助けになったりとか、ライブラリを使うことで簡単に実装できたりします。見てるだけでも楽しいです。</p>

<h2><a href="https://github.com/square">Square</a></h2>

<p>決済サービスのあのスクエアのGitHubアカウントです。dagger、otto、picasso、fest-androidなど、これらの有名なライブラリも実はこのスクエア製で、インタフェースの素晴らしさも去ることながら、プログラムがとても綺麗で、ある意味書籍よりも勉強になると思います。</p>

<hr />

<h2>まとめ</h2>

<p>こんなに一度に紹介されても読むのはたいへん…ですが、まずは調べてみて興味を持ったところから読んでみるといいと思います。
スマートフォンエンジニアはデザインから低レイヤまで幅広い知識を要求されます(といってもエンジニアリングってどの分野もそうなのですが)が、まずは自分の好きを伸ばして、それからもっと良いアプリを作るために、足りないところを補っていくというやり方がいいのかなと思いました。</p>
]]></content>
  </entry>
  
</feed>
