<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Just posted a blog]]></title>
  <link href="http://takiguchi0817.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://takiguchi0817.github.com/"/>
  <updated>2013-06-18T22:49:02+09:00</updated>
  <id>http://takiguchi0817.github.com/</id>
  <author>
    <name><![CDATA[rejasupotaro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RouteActivityを作ろう]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/06/18/route-activity/"/>
    <updated>2013-06-18T22:16:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/06/18/route-activity</id>
    <content type="html"><![CDATA[<h2>理由1. LauncherのActivityは太りやすい</h2>

<p>Androidのプロジェクトを作ると最初にMainActivityが作られます。
そのMainActivityを中心にアプリを作っていくと、認証の確認を行うロジックを入れたり、思わぬ初期化処理が必要になったりして、規模が大きくなるごとにどんどんActivityが太ってしまいます。
ユーザーから最初に見える画面は出来るだけ速く表示したいですし、分岐がたくさん入ると見通しが悪くなって変更がしづらくなる、という状態は避けたいです。</p>

<h2>理由2. アプリの起動の口が複数あるとコピペが発生しやすい</h2>

<p>Androidはショートカットや通知など、画面を起動するパスがたくさんあります。
素直な実装をすると、すべてのActivityのonCreateの中で、isAuthenticatedみたいなメソッドを生やしてログインしてなかったらログイン画面に飛ばしたり、どの経路からアプリが起動されたかログを取る処理などを書いたりして、コピペが発生してActivityの見通しが悪くなってしまいます。</p>

<p>かといって共通の親クラスを作るという方法は、あまりやりたくありません。</p>

<h2>RouteActivityを作ろう</h2>

<p>プロジェクトを作成したらまず最初にMainActivityをRouteActivityにリネームします。
そして、ショートカットやIntentFilterなどはすべてRouteActivityを起動するようにして、パラメータで遷移先を変えるようにします。
RouteActivityに認証の確認の処理や、初期化処理などを置いて、各Activityはそれぞれの責務を真っ当させたら、コードが綺麗になるのではないかと思いました。</p>

<p>RouteActivityという名前はRailsのconfig/routes.rbから来ています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テンプレートアプリ "katanuki" を作った]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/04/28/android-katanuki/"/>
    <updated>2013-04-28T16:47:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/04/28/android-katanuki</id>
    <content type="html"><![CDATA[<h1><a href="https://github.com/takiguchi0817/katanuki">Android Katanuki</a></h1>

<p>A template application that includes tons of great open source tools and frameworks.</p>

<p><img src="https://raw.github.com/takiguchi0817/katanuki/master/katanuki.png" width="640" height="480"></p>

<h1>経緯</h1>

<p>この前、<a href="http://androidkickstartr.com/">AndroidKickstartR</a>というプロジェクトを見つけました。</p>

<p><img src="https://dl.dropboxusercontent.com/u/54255753/blog/201304/androidkickstartr.png" width="640" height="480"></p>

<p>これは自分が使いたいライブラリを選んでポチポチ選んで "Download it!" を押したらAndroidアプリのテンプレートが落とせるというものです。
ハッカソンとかで便利そう。
雛形を提供するプロジェクトは他にも
<a href="android%20katanuk://github.com/donnfelker/android-bootstrap">Android Bootstrap</a>
などもあります。</p>

<p>で、各々がサポートしているライブラリが以下になります。</p>

<h3>AndroidKickstartR</h3>

<ul>
<li>android-maven-plugin</li>
<li>AndroidAnnotations</li>
<li>ActionBarSherlock</li>
<li>Spring RESTTemplate</li>
<li>Android support v4</li>
<li>NineOldAndroid</li>
<li>ACRA</li>
<li>RoboGuice</li>
</ul>


<h3>Android Bootstrap</h3>

<ul>
<li>ActionBarSherlock</li>
<li>Dagger</li>
<li>Butterknife</li>
<li>Otto</li>
<li>Robotium</li>
<li>android-maven-plugin</li>
<li>http-request</li>
<li>google-gson</li>
</ul>


<p>新しいアプリを作るときのセットアップってほぼ作業だし、
毎回同じことをしてる気がしたので、自分用のアプリのテンプレートを作りました。
作ったというより設定を書いた、の方が近いですが。
（なぜわざわざ作ったかというと自分の使いたいライブラリや書き方が、上のテンプレートと微妙に合わなかったからです。）</p>

<h1>katanukiについて</h1>

<p>このテンプレートは、プロトタイプ作成や一日でアプリを組むハッカソンを想定して作りました。
今から数時間でそれっぽいアプリを作るぞ！と思ったときに、何をすれば良いか考えて、</p>

<ol>
<li>APIを叩く</li>
<li>データを保存する</li>
<li>かっこいいUIを作る</li>
</ol>


<p>と作業を分解して、APIを叩くのにhttp-request、レスポンスのjsonをオブジェクトに変換するのにgson、それらをAsyncTaskLoaderで呼び出すようにしました。</p>

<p>次にデータの保存はActiveAndroidを使いました。エンタープライズでは使わないと思いますが、面倒なDB周りのコードを書く時間をバッサリカットできるので便利です。</p>

<p>UIについては、入れようか迷ったのですが、中のロジックは一緒でも見せ方はケースバイケースかなと思ったので入れませんでした。
プロジェクトには含めてませんが、このあたりが便利そうです。</p>

<ul>
<li><a href="https://github.com/JakeWharton/ActionBarSherlock">ActionBarSherlock</a> : ActionBarのcompatibility library</li>
<li><a href="https://github.com/chrisbanes/Android-PullToRefresh">PullToRefresh</a> : 引っ張り更新</li>
<li><a href="https://github.com/Prototik/HoloEverywhere">HoloEverywhere</a> : Holoを2系でも使えるようにする</li>
<li><a href="https://github.com/SimonVT/android-menudrawer">MenuDrawer</a> : 横から出るメニューの実装</li>
</ul>


<p>OpenSource便利。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Otto 使ってみた]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/04/15/using-otto/"/>
    <updated>2013-04-15T21:25:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/04/15/using-otto</id>
    <content type="html"><![CDATA[<h1><a href="http://square.github.io/otto/">Otto - An event bus by Square</a></h1>

<p>画像のアップロード処理が終わったらActivityに通知するとか、
DBからデータを消したらViewに反映させるとかしたくなることってよくあると思います。</p>

<p>Interfaceでなんとかしようとするとコードが汚くなってやだなと思ってたので、前から気になってたevent busのライブラリ、Ottoを使ってみました。</p>

<h2>バッググラウンドで画像のアップロードが終わったらトーストを出す</h2>

<p>Busですが、インスタンスごとにregisterとunregisterが出来るのですが、通常はSingletonで良いでしょう。
```java
public final class BusProvider {
  private static final Bus BUS = new Bus(ThreadEnforcer.ANY);</p>

<p>  public static Bus getInstance() {</p>

<pre><code>return BUS;
</code></pre>

<p>  }</p>

<p>  private BusProvider() {</p>

<pre><code>// No instances.
</code></pre>

<p>  }
}
```
Busのインスタンスの生成のときに実行するスレッドのチェックが出来るのですが、
event busを使うときってバックグラウンドスレッドからメインスレッドに通知するパターンが多そうなので、
ThreadEnforcer.ANYを指定しています。</p>

<p>イベントの発火。
```java
public class ImageUploaderService extends ProtonIntentService {</p>

<pre><code>private static final String TAG = ImageUploaderService.class.getSimpleName();
public static final String EXTRA_UPLOAD_ENTITY = "extra_animation_entity";
@Inject MyNotificationManager mNotificationManager;

public ImageUploaderService() {
    super(TAG);
}

public ImageUploaderService(String name) {
    super(name);
}

@Override
protected void onHandleIntent(Intent intent) {
    mNotificationManager.sendNotification();
    UploadEntity uploadEntity = intent.getParcelableExtra(EXTRA_UPLOAD_ENTITY);
    MyApiClient apiClient = new MyApiClient(this, uploadEntity);
    boolean result = apiClient.execute();
    Log.d(TAG, "upload result: " + result);
    mNotificationManager.cancelNotification();
    BusProvider.getInstance().post(new UploadFinishedEvent());
}
</code></pre>

<p>}
```
bus#postに定義したイベントのインスタンスを渡します。</p>

<p>イベントはなんでもいいです。
<code>java
public class UploadFinishedEvent {
}
</code>
今回は特になにも渡すものがないので空です。</p>

<p>メソッドに@Subscribeを付けて定義したイベントを引数にすると受け取ることが出来ます。
```java
public class MyActivity extends Activity {</p>

<pre><code>...

@Override
public void onResume() {
    super.onResume();
    BusProvider.getInstance().register(this);
}

@Override
protected void onPause() {
    super.onPause();
    BusProvider.getInstance().unregister(this);
}

@Subscribe
public void onUploadFinished(UploadFinishedEvent event) {
    mHandler.post(new Runnable() {
        @Override
        public void run() {
            ToastUtils.show(AnimationComposeActivity.this, R.string.upload_finished);
        }
    });
}
</code></pre>

<p>}
```
ActivityではonResumeとonPauseでそれぞれregisterとunregisterをしてやる必要があります。</p>

<p>これだけでイベント通知のしくみが使えてとても便利。</p>

<p><blockquote class="twitter-tweet" lang="ja"><p>Otto、シンプルだしコード綺麗だしパフォーマンスを考慮してtraverseしないのもいい / An enhanced Guava-based event bus with emphasis on Android support. <a href="http://t.co/2yHWQkejEd" title="http://square.github.io/otto/">square.github.io/otto/</a></p>&mdash; レジャスポ太郎さん (@rejasupotaro) <a href="https://twitter.com/rejasupotaro/status/323451917235789824">2013年4月14日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年 Androidアプリ開発で使いたいライブラリ]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/03/10/android-libraries/"/>
    <updated>2013-03-10T22:35:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/03/10/android-libraries</id>
    <content type="html"><![CDATA[<p>30億のデバイスのみなさん、こんにちは、ジャバです。</p>

<p><img src="http://dl.dropbox.com/u/54255753/blog/201303/javamonster.gif" alt="迫り来るジャバモンスター" /></p>

<p>何の前触れもなく、2013年 Androidアプリ開発で使いたいライブラリを発表します。</p>

<h2>JsonConverter => <a href="https://code.google.com/p/google-gson/">gson</a></h2>

<p>JSONRPCでサーバーサイドと通信を行うときに、毎回パーサーを書くのは面倒なので、JsonConverterを使いたくなります。
そこで開発ではgoogleが開発しているgsonを使っていました。
NamingPolicyやDeserializerの使い方を覚えれば、手でjsonのパーサーを書くより圧倒的に楽で、</p>

<pre><code>Person person = gson.fromJson(json, Person.class);
</code></pre>

<p>このように一行でjsonからオブジェクトに変換できるようになり、</p>

<pre><code>String json = gson.toJson(person);
</code></pre>

<p>一行でオブジェクトからStringに変換することも出来ます。
なので、preferenceに保存 => 復旧もすごく便利になります。もうSerializableはやめましょう！</p>

<p>ただ、gsonは各々の型の変換のためにTypeAdapterを保持しているというのと、変換にはリフレクションを使っているので、パフォーマンスはあまり良くないです。
また、レスポンスのjsonの構造がクラスになってしまうので、変換したクラスをそのままモデルとして使おうとすると柔軟性が下がってしまいます。なので、使うのであれば</p>

<pre><code>json =&gt; api entity =&gt; model
</code></pre>

<p>ってしたい感じです。</p>

<h2>ORM => <a href="https://www.activeandroid.com/">ActiveAndroid</a> or <a href="http://greendao-orm.com/">greenDAO</a></h2>

<p>SQL文をHelperに記述してるときは人間らしい心を失いそうになります。そして、人間はtypoする生き物なのでDBのバージョンアップで死んだりすることもあります。<br/>
そこでORMということになるのですが、AndroidのORMでは、RailsのAndroid版であるActiveAndroidというのがあります。
ただし、Active Recordパターンの欠点もそのままなので、"構築が容易であり理解もしやすい"代償としてそのままでは複雑なロジックを扱いづらくなります。
ドメイン層とパーシステンス層が一緒になったのがActive Recordパターンなので、Rubyみたいにmixinができる言語は良いけど、ジャバだとテストが書きづらくなるので、あまりオススメしない、って某氏が言ってました。
データアクセスに関しては <a href="http://www.oracle.com/technetwork/jp/articles/index-087873-ja.html">データアクセスことはじめ</a> が勉強になりました。</p>

<p>あまり規模が大きくないならActiveAndroidは記述量が減るし読みやすいしで、良い選択肢だと思います。
それ以上なら、ORMLiteを高速化したgreenDAOを使うのが良いかもしれません。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/12321475" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="http://www.slideshare.net/droidcon/green-dao" title="Green dao" target="_blank">Green dao</a> </strong> from <strong><a href="http://www.slideshare.net/droidcon" target="_blank">Droidcon Berlin</a></strong> </div></p>

<h2>DI => <a href="https://github.com/roboguice/roboguice">RoboGuice</a> or <a href="https://github.com/hnakagawa/proton">Proton</a> or <a href="http://square.github.com/dagger/">Dagger</a></h2>

<p>Fragmentのイベントを別のFragmentで作用させたいときに、interfaceを定義してActivity経由でlistenerを登録とかするとすぐにlistener地獄になってしまってつらいです。
そういうときにContextSingletonなヘルパーをインジェクトして使うとめちゃ便利で、コードの見通しが良くなって仕様変更に強くなって心が豊かになってモテ始めたりすると思います。
他にもテスト実行時にインジェクトするオブジェクトを切り替えられるとか、記述が楽になる以外にもメリットはたくさんあると思います。</p>

<p>有名なのはRoboGuiceです。これはサーバーサイドのDIフレームワークのGuiceを、Androidでも使えるようにラップしたものです。
サーバーサイドを想定して作られたものなので、無駄が多かったりするのですが、それなりにドキュメントがあって実績もあります。</p>

<p>そんなRoboGuiceを見て後述のTriainaフレームワークの開発者の人が、
「RoboGuice無駄に大きしTypeListenerとかいらんし、もっと早くて軽いのをフルスクラッチで書く」
と言って作られたのがProtonです。いらない機能を削ってAndroidに最適化した結果、サイズもメモリ使用量も圧倒的に少なくなったとのことです。
ただドキュメントがないので使うならRoboGuiceの知識が必須で、ソースコードを読みながらになると思います。</p>

<p>RoboActivityとかProtonActivityとか継承したくない、かつコンテキストシングルトンとかいらない！というケースであれば、単純にインジェクトだけが出来るDagger良いです。</p>

<h1>おわりに</h1>

<p>もうちょっと書こうと思ったのですが意外と書くのがたいへんだったので突然ブログは終わります。他にも、</p>

<ul>
<li>event busの<a href="http://square.github.com/otto/">Otto</a></li>
<li>WebView Bridgeの<a href="https://github.com/mixi-inc/triaina">Triaina</a></li>
<li>Code Dietが出来る<a href="http://androidannotations.org/">AndroidAnnotations</a></li>
<li>jQueryのAndroid版の<a href="https://code.google.com/p/android-query/">android-query</a></li>
</ul>


<p>とかあるので、また検証をしたら個別に記事を書こうと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Androidアプリを作るときに気を付けること(セキュリティ)]]></title>
    <link href="http://takiguchi0817.github.com/blog/2013/01/15/android-security/"/>
    <updated>2013-01-15T23:28:00+09:00</updated>
    <id>http://takiguchi0817.github.com/blog/2013/01/15/android-security</id>
    <content type="html"><![CDATA[<h3>Androidセキュリティあるあるをまとめてみました。</h3>

<p>　</p>

<h4><input type="checkbox">アプリケーションデータディレクトリの外に個人情報を置いていないか？</h4>

<p>基本的に個人情報はSDカードや他のディレクトリに置いてはいけません。
どうしても置きたい場合は<a href="http://takiguchi0817.github.com/blog/2012/12/31/java-aes/">暗号化</a>します。</p>

<h4><input type="checkbox">WebViewでGETパラメータでCookieやトークンを渡していないか？</h4>

<p>LogCatに出てしまいます。ただし、Jelly Beanからは<a href="http://blog.2maru.com/archives/1700">LogCatが読めなくなりました</a>。</p>

<h4><input type="checkbox">WebViewで許可されたドメイン以外にJavaScriptInterfaceが公開されていないか？</h4>

<p>JavaScriptInterfaceからクラスローダーが取得できたりJNIが呼べたりしてしまうので<a href="https://www.google.co.jp/#hl=ja&amp;q=Android+WebView+%E5%8D%B1%E9%99%BA&amp;fp=1">たいへん危険</a>です。</p>

<h4><input type="checkbox">ContentProviderのパーミッションは適切か？</h4>

<p>コンテントプロバイダはデフォルトで公開されているので注意が必要です。
また2.2以前だと<a href="http://www.taosoftware.co.jp/blog/2011/10/android_contentproviderexport.html">exportedをfalseにしていても</a>外部アプリから情報が読めてしまいます。</p>

<h4><input type="checkbox">Broadcastのパーミッションは適切か？</h4>

<p>パーミッションを付け忘れると外に情報が出てしまいます。
またStickyブロードキャストはパーミッションが指定できないので個人情報を入れてはいけません。</p>

<h4><input type="checkbox">端末固有の識別子をサーバ側でIDとして使っていないか？</h4>

<p><a href="http://news.mynavi.jp/articles/2012/03/28/abc2012_06/index.html">怖い人</a>が飛んでくるおそれがあります。
　<br/>
　</p>

<h3>まとめ</h3>

<p>脆弱性のあるアプリを一度世に出してしまったら、いくらセキュリティパッチをあてたところで、ユーザにアップデートをしてもらえなければそれまでです。
ちょっとした注意で防げるものもあるので、外部からの攻撃ならまだしも、こちら側で防げるものは確実に防いでおきたいですね。</p>
]]></content>
  </entry>
  
</feed>
